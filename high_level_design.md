[Project Summary](index.md) | [Use Cases](use_cases.md) | [Requirements](requirements.md) | [High-Level Design](high_level_design.md)
[Modules](modules.md) | [Design Rationale](design_rationale.md) | [Conclusion](conclusion.md)

## High-Level Design

![project_structure](https://user-images.githubusercontent.com/24898162/95663810-2dc1f400-0b10-11eb-8895-3442f89bb910.png)

Before getting our heads down and moving forward with any architectural design, we have brainstormed and come up with a number of questions which are crucial to the design direction. Those questions can be classified into two major categories: system architecture and business logics.

System architecture related questions: If we were a real startup tech company, with a limited budget, what is the best software architectural solution for the initial hardware and equipment setup? If the business determined that we need to support multiple user platforms, what would be the best design to satisfy such requirements? If the business becomes successful and hits the market really well, is the system able to scale big and fast enough to accommodate the increased visiting volume? Although this is not a mission critical system, what should we do to ensure the system’s high availability to give the customer a better experience? Since the system is handling customer’s payment information, what should we do to secure customer’s financial information?

Business logics related questions: Who are our target users? What are the most common use case scenarios? Are the customers only visiting websites through desktop browsers, or they are also using mobile applications for those use cases? Or if the mobile version can provide more benefits, should we focus more on the mobile applications? What is the core value proposition this system provides to our customers compared to other similar applications or websites? Is this a customer-centric system in which all the components are designed in such a way that support different function flows to meet customer needs?

With the aforementioned questions in mind, the architectural design of our hotel booking system is based on the popular client-server architecture that has been adopted by the majority of the modern websites and mobile applications. The decoupled design gives the great flexibility for multiple user flatforms. It addresses the question regarding which platform should the system support. Since the server side system provides micro services and APIs for the client side systems to consume, as long as the client side systems are designed to conform with the API standard. Therefore the system allows multiple front-end user platforms, such as web, Android, iOS, or even voice assistant systems like Alex, Google Home and Siri. However, if this is for a real startup project, the stakeholders don’t have to go all out to implement multiple front-end platforms at the same time. They have the choice to start with only one platform, and gradually expand to other platforms when budget and other resources permitted.

Despite the fact that the form and appearance of different front-end platforms may vary, they share the same architectural design fundamentally. The client side system includes the main user interface, core function modules, and other system management function modules. It is running on the customer’s machine, i.e. inside the browser for websites, installed as binary apps for mobile devices. It cannot function by itself unless connected via micro services and APIs to the server side system. The client side system is only responsible for consuming the data passed from the server and presenting the data to the UI in the way that the designer created for the best user experience. It is not responsible for any crucial business logics. Although the binary or the content of the client side code must be encrypted and obfuscated before distributed to the customers, since once the binary or code goes out of the door, it is not under the control of the company anymore, there are still possibilities it may be decrypted and reversed engineered by malicious third parties. Storing and using the critical business logic in the client side system is definitely not recommended.  
